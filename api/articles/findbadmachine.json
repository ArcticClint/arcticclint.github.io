{"title":"快速找出故障机器","uid":"60ae5f459fdbd2a4d5acb3ac37fc6541","slug":"findbadmachine","date":"2016-09-26T03:33:26.000Z","updated":"2022-01-28T05:54:33.091Z","comments":true,"path":"api/articles/findbadmachine.json","keywords":"博客","cover":"https://tse3-mm.cn.bing.net/th/id/OIP-C.cw_ZymcoFQL86v57DeTyvAHaEm?w=283&h=180&c=7&r=0&o=5&pid=1.7","content":"<p>关心数据挖掘和搜索引擎的朋友都知道，我们需要很多的计算机来存储和处理海量数据。然而，计算机难免出现硬件故障而导致网络联系失败或死机。为了保证搜索引擎的服务质量，我们需要保证每份数据都有多个备份。</p>\n<p>简单起见，我们假设一个机器仅储存一个标号为ID的记录（假设ID是小于10亿的整数），假设每份数据保存两个备份，这样就有两个机器储存了同样的数据。</p>\n<ol>\n<li>在某个时间，如果得到一个数据文件ID的列表，是否能够快速地找出这个表中仅出现一次的ID？</li>\n<li>如果已经知道只有一台机器死机（也就是说只有一个备份丢失）呢？如果有两台机器死机呢（假设同一个数据的两个备份不会同时丢失）？</li>\n</ol>\n<h3 id=\"分析与解法\"><a href=\"#分析与解法\" class=\"headerlink\" title=\"分析与解法\"></a>分析与解法</h3><div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">TIP</p>\n<p><h4 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h4><p>这个问题可以转化成：有很多的ID，其中只有一个ID出现的次数小于2，其他正常ID出现的次数都等于2，问如何找到这个次数为1的ID。</p>\n<p>为了达到这个目的，最简单的办法就是直接遍历列表，利用一个数组记下每个ID出现的次数，遍历完毕之后，出现次数小于2的ID就是我们想要的结果。假设有N个ID，且ID的取值在0～（N-1）之间，这个解法占用的时间复杂度为O(N)，空间复杂度为O(N)。</p>\n<p>时间复杂度已经相当理想，但是空间复杂度仍觉不够理想。如果ID的数量多达几GB甚至几十GB，这样的空间复杂度在实际的运算中就会带来效率问题。那么，是否有办法进一步地减少空间复杂度呢？</p>\n<h4 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h4><p>仔细思考一下，哪些数据是不必存储的呢？大部分的机器ID出现次数都等于2，这些ID的信息有必要吗？我们可以利用这样一个特性：ID出现次数等于2的机器肯定不是故障的机器，可以不予考虑。因此，可以把解法1数组中等于2的元素清空，然后用来存储下一个机器ID的出现次数，这样就可以减少需要的空间。</p>\n<p>具体方法如下：遍历列表，利用哈希表记下每个ID出现的次数，每次遇见一个ID，就向哈希表中增加一个元素；如果这个ID出现的次数为2，那么就从哈希表中删除这个ID，最后剩下的ID就是我们想要的结果。这个算法空间复杂度在最好情况下可以达到O(1)，在最坏情况下仍然是O(N)。</p>\n<h4 id=\"解法三\"><a href=\"#解法三\" class=\"headerlink\" title=\"解法三\"></a>解法三</h4><p>前面的两个算法的时间复杂度已经达到了O(N)，并且空间复杂度也已经有了一定的突破，那么是否有可能进一步提高算法的性能呢？</p>\n<p>分别从时间复杂度，空间复杂度方面考虑，时间复杂度上面很难有太大的突破。因为，已经降到了O(N)这个规模了。那么，空间复杂度呢？</p>\n<p>如果想继续降低空间复杂度，就要摒弃遍历列表计数这种方法了，考虑采用完全不同的模式来计算。</p>\n<p>如果空间复杂度仍然在N这个级别，其实也没有降多少。是否可以降到常数级别呢？更加极端一点，是否可能使得空间复杂度降为O(1)，也就是说只利用一个变量来记录遍历列表的结果。</p>\n<p>如果这样，我们可以把这个变量写成：x(i)=f(list[0],list[1], …,list[i])，也就是说这个变量是已经遍历过的列表元素的函数。这个函数需要满足的条件就是：x(N)=ID_Lost。也就说遍历完整个列表后，这个变量的值应该等于丢失备份的ID。</p>\n<p>我们需要做的就是寻找合适的f。</p>\n<p>显然，f的形式不只一种。那么，我们可以先考虑找出一种可行的函数。对于第一问，我们已经知道，列表中仅有一个ID出现了一次。那么，可以考虑使用异或关系来帮忙找到结果。</p>\n<p>因为X⊕X=0且X⊕0=X，因此，可以把这个关系应用到构造这个函数上面。因为，正确的机器都会有两个ID，不正确的机器只有一个ID。所以所有ID的异或值就等于这个仅出现一次的ID（因为异或运算满足交换律和结合律，其他出现两次的ID异或完都为0）。这样我们只使用一次遍历运算就得到了只有一台故障机器情况下故障机器的ID。<br>因此，就可以使用x(i)=list[0]⊕list[1]⊕…⊕list[i]来作为结果值。</p>\n<p>在这样的情况下，时间复杂度为O(N)，由于只需要保存一个运算结果，因此空间复杂度为O(1)。</p>\n<p>对于第二问，由于有两个ID仅出现了一次，设它们为A和B，那么所有ID的异或值为A⊕B（道理同上面分析的一样）。但还是无法确定A和B的值。</p>\n<p>可以进行分类讨论：如果A=B，则A⊕B为0，也就是说丢失的是同一份数据的两个拷贝，我们可以通过求和的方法得到A和B（A=B=(所有ID之和-所有正常工作机器ID之和)/2）。如果A⊕B不等于0，那么这个异或值的二进制中某一位为1。显然，A和B中有且仅有一个数的相同位上也为1。</p>\n<p>我们就把所有ID分成两类，一类在这位上为1，另一类这位上为0。那么对于这两类ID，每一类分别含有A和B中的一个。那么我们使用两个变量，在遍历列表时，分别计算这两类ID的异或和，即可得到A和B的值。</p>\n</div>\n","text":"关心数据挖掘和搜索引擎的朋友都知道，我们需要很多的计算机来存储和处理海量数据。然而，计算机难免出现硬件故障而导致网络联系失败或死机。为了保证搜索引擎的服务质量，我们需要保证每份数据都有多个备份。 简单起见，我们假设一个机器仅储存一个标号为ID的记录（假设ID是小于10亿的整数），...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"algorithm","slug":"algorithm","count":5,"path":"api/categories/algorithm.json"}],"tags":[{"name":"趣题","slug":"趣题","count":3,"path":"api/tags/趣题.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E6%B3%95\"><span class=\"toc-text\">分析与解法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%B3%95%E4%B8%80\"><span class=\"toc-text\">解法一</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%B3%95%E4%BA%8C\"><span class=\"toc-text\">解法二</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%B3%95%E4%B8%89\"><span class=\"toc-text\">解法三</span></a></li></ol></li></ol>","author":{"name":"ArcticTime","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/22902414?s=400&u=5ba620686e56ccff3fba9fffaadb3244bdc6de4d&v=4","link":"/","description":"当前目标是八块腹肌","socials":{"github":"https://github.com/ArcticClint","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"图片转字符","uid":"f0a9f68103bafda08057b264814a6ae9","slug":"pic2str","date":"2017-08-15T10:49:36.000Z","updated":"2022-01-28T05:52:15.724Z","comments":true,"path":"api/articles/pic2str.json","keywords":"博客","cover":"https://tse3-mm.cn.bing.net/th/id/OIP-C.lEtIXTn3-jk7zZxFzFnDvgHaEK?w=298&h=180&c=7&r=0&o=5&pid=1.7","text":"usage: python pic2str.py xxx.jpg Click to see code # coding:utf-8 # 为一张图片生成对应的字符集图片 import Image import argparse # 命令行输入参数处理 parser = argpar...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"python","slug":"python","count":1,"path":"api/categories/python.json"}],"tags":[{"name":"tools","slug":"tools","count":2,"path":"api/tags/tools.json"}],"author":{"name":"ArcticTime","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/22902414?s=400&u=5ba620686e56ccff3fba9fffaadb3244bdc6de4d&v=4","link":"/","description":"当前目标是八块腹肌","socials":{"github":"https://github.com/ArcticClint","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"变量的生命周期","uid":"58a4a42098697b821aac8fa044fb7928","slug":"varlifecycle","date":"2016-08-20T10:26:05.000Z","updated":"2022-02-16T10:44:50.288Z","comments":true,"path":"api/articles/varlifecycle.json","keywords":"博客","cover":"https://tse4-mm.cn.bing.net/th/id/OIP-C.-QEC7GzzKlQr8X9pKBpYTAHaEK?w=317&h=180&c=7&r=0&o=5&pid=1.7","text":"变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。对于在包一级声明的变量 来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的声明周期 则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"golang","slug":"golang","count":3,"path":"api/categories/golang.json"}],"tags":[{"name":"tips","slug":"tips","count":2,"path":"api/tags/tips.json"}],"author":{"name":"ArcticTime","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/22902414?s=400&u=5ba620686e56ccff3fba9fffaadb3244bdc6de4d&v=4","link":"/","description":"当前目标是八块腹肌","socials":{"github":"https://github.com/ArcticClint","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}