{"title":"变量的生命周期","uid":"58a4a42098697b821aac8fa044fb7928","slug":"varlifecycle","date":"2016-08-20T10:26:05.000Z","updated":"2022-02-16T10:44:50.288Z","comments":true,"path":"api/articles/varlifecycle.json","keywords":"博客","cover":"https://tse4-mm.cn.bing.net/th/id/OIP-C.-QEC7GzzKlQr8X9pKBpYTAHaEK?w=317&h=180&c=7&r=0&o=5&pid=1.7","content":"<p>变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。对于在包一级声明的变量 来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的声明周期 则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。 </p>\n<p>那么Go的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。</p>\n<p>因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期 可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。</p>\n<p>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。</p>\n <pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> global <span class=\"token operator\">*</span><span class=\"token builtin\">int</span> \n<span class=\"token keyword\">func</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> \n    <span class=\"token keyword\">var</span> x <span class=\"token builtin\">int</span> \n    x <span class=\"token operator\">=</span> <span class=\"token number\">1</span> \n    global <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>x \n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> \n    y <span class=\"token operator\">:=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> \n    <span class=\"token operator\">*</span>y <span class=\"token operator\">=</span> <span class=\"token number\">1</span> \n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量 *y 将是不可达的，也就是说可以马上被回收的。因此， *y并没有从函数g中逃逸，编译器可以选择在栈上分配 *y的存储空间（也可以选择在堆上分配，然后由Go的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。</p>\n<p> Go的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中， 特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。</p>\n","text":"变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。对于在包一级声明的变量 来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的声明周期 则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"golang","slug":"golang","count":3,"path":"api/categories/golang.json"}],"tags":[{"name":"tips","slug":"tips","count":2,"path":"api/tags/tips.json"}],"toc":"","author":{"name":"ArcticTime","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/22902414?s=400&u=5ba620686e56ccff3fba9fffaadb3244bdc6de4d&v=4","link":"/","description":"当前目标是八块腹肌","socials":{"github":"https://github.com/ArcticClint","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"快速找出故障机器","uid":"60ae5f459fdbd2a4d5acb3ac37fc6541","slug":"findbadmachine","date":"2016-09-26T03:33:26.000Z","updated":"2022-01-28T05:54:33.091Z","comments":true,"path":"api/articles/findbadmachine.json","keywords":"博客","cover":"https://tse3-mm.cn.bing.net/th/id/OIP-C.cw_ZymcoFQL86v57DeTyvAHaEm?w=283&h=180&c=7&r=0&o=5&pid=1.7","text":"关心数据挖掘和搜索引擎的朋友都知道，我们需要很多的计算机来存储和处理海量数据。然而，计算机难免出现硬件故障而导致网络联系失败或死机。为了保证搜索引擎的服务质量，我们需要保证每份数据都有多个备份。 简单起见，我们假设一个机器仅储存一个标号为ID的记录（假设ID是小于10亿的整数），...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"algorithm","slug":"algorithm","count":5,"path":"api/categories/algorithm.json"}],"tags":[{"name":"趣题","slug":"趣题","count":3,"path":"api/tags/趣题.json"}],"author":{"name":"ArcticTime","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/22902414?s=400&u=5ba620686e56ccff3fba9fffaadb3244bdc6de4d&v=4","link":"/","description":"当前目标是八块腹肌","socials":{"github":"https://github.com/ArcticClint","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"fetchall","uid":"74f85ec3f0b5983378594eef7eff81a2","slug":"fetchall","date":"2016-08-14T02:50:08.000Z","updated":"2022-02-16T10:34:15.083Z","comments":true,"path":"api/articles/fetchall.json","keywords":"博客","cover":"https://tse4-mm.cn.bing.net/th/id/OIP-C.-QEC7GzzKlQr8X9pKBpYTAHaEK?w=317&h=180&c=7&r=0&o=5&pid=1.7","text":"解析goroutine是一种函数的并发执行方式，而channel是用来在goroutine之间进行参数传递。main函数本身也运行在一个goroutine中，而go function则表示创建一个新的goroutine，并在这个新的goroutine中执行这个函数。 main函数...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"golang","slug":"golang","count":3,"path":"api/categories/golang.json"}],"tags":[{"name":"tips","slug":"tips","count":2,"path":"api/tags/tips.json"}],"author":{"name":"ArcticTime","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/22902414?s=400&u=5ba620686e56ccff3fba9fffaadb3244bdc6de4d&v=4","link":"/","description":"当前目标是八块腹肌","socials":{"github":"https://github.com/ArcticClint","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}