[{"id":"0e6870079fdec95a13a2648b13457a77","title":"网络空间搜索引擎","content":"简单介绍Shodanhttps://www.shodan.io/\nShodan 是全球第一个网络设备搜索引擎，发布于 2009 年\nFOFAhttps://fofa.so/\nFOFA 是白帽汇推出的一款网络空间搜索引擎，可以快速进行网络资产匹配\nQuakehttps://quake.360.cn/quake/#/index\nQuake 是 360 网络安全响应中心自主研发设计的全网空间测绘系统\nZoomEyehttps://www.zoomeye.org/\nZoomEye（“钟馗之眼”）是知道创宇旗下404实验室驱动打造的中国第一款网站空间搜索引擎。其实在 ZoomEye 发布前，Shodan 把这种搜索引擎更多叫做网络设备搜索引擎，而国内更习惯使用网络空间搜索引擎这个概念，据说这个概念是知道创宇安全公司于 2013 年首次在国内提出的\n\n\n","slug":"cybersearchengine","date":"2019-10-28T08:46:58.000Z","categories_index":"","tags_index":"tools","author_index":"ArcticTime"},{"id":"ea2df330bdc4d3b0275544f615da7198","title":"gomail基本用法","content":"GoMail基本用法\nClick to see code\n// Example\n\nm := gomail.NewMessage()\nm.SetHeader(\"From\", \"alex@example.com\")\nm.SetHeader(\"To\", \"bob@example.com\", \"cora@example.com\")\nm.SetAddressHeader(\"Cc\", \"dan@example.com\", \"Dan\")\nm.SetHeader(\"Subject\", \"Hello!\")\nm.SetBody(\"text/html\", \"Hello &lt;b>Bob&lt;/b> and &lt;i>Cora&lt;/i>!\")\nm.Attach(\"/home/Alex/lolcat.jpg\")\n\nd := gomail.NewDialer(\"smtp.example.com\", 587, \"user\", \"123456\")\n\n// Send the email to Bob, Cora and Dan.\nif err := d.DialAndSend(m); err != nil &#123;\n\tpanic(err)\n&#125;\n\n\n// NoAuth\n\nm := gomail.NewMessage()\nm.SetHeader(\"From\", \"from@example.com\")\nm.SetHeader(\"To\", \"to@example.com\")\nm.SetHeader(\"Subject\", \"Hello!\")\nm.SetBody(\"text/plain\", \"Hello!\")\n\nd := gomail.Dialer&#123;Host: \"localhost\", Port: 587&#125;\nif err := d.DialAndSend(m); err != nil &#123;\n\tpanic(err)\n&#125;\n\n\n","slug":"gomail","date":"2019-03-11T03:50:45.000Z","categories_index":"golang","tags_index":"email","author_index":"ArcticTime"},{"id":"ace00f99753694b20f6a827acf26990a","title":"简单记录下ssh隧道","content":"\n\n\n\n\n\nTIP\n什么是隧道？在实际的网络中，通常会通过各种边界设备、软/硬件防火墙甚至入侵检测系统来检查对外连接情况，如果发现异样，就会对通信进行阻断。那么什么是隧道呢？这里的隧道，就是一种绕过端口屏蔽的通信方式。防火墙两端的数据包通过防火墙所允许的数据包类型或端口进行封装，然后穿过防火墙，与对方进行通信。当封装的数据包到达目的地时，将数据包还原，并将还原后的数据包发送到相应服务器上。\n\n应用层隧道技术应用层（Application layer）是七层OSI模型的第七层。应用层直接和应用程序接口并提供常见的网络应用服务。应用层的隧道技术主要利用应用软件提供的端口来发送数据，常用的协议有SSH、HTTP/HTTPS和DNS。\nSSH协议SSH 为建立在应用层基础上的安全协议，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH客户端适用于多种平台，几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、DigitalUNIX、Irix，以及其他平台，都可运行SSH。一般情况下，SSH协议的传输是被允许通过防火墙及边界设备的，且SSH传输过程加密，很难区分是合法的SSH会话还是攻击者建立的隧道，所以经常被攻击者所利用。攻击者使用SSH隧道突破防火墙限制后，能够建立一些之前无法建立的TCP连接。\nSSH 命令ssh 用户名@ip -p &lt;端口号&gt;\n创建ssh隧道常用的参数-C：压缩传输，提高传输速度\n-f：将ssh传输转入后台执行，不占用当前的shell\n-N：静默连接，连接后看不到具体会话\n-g：允许远程主机连接本地用于转发的端口\n-L：本地端口转发\n-R：远程端口转发\n-D：动态转发（SOCKS 代理）\n-p：指定ssh端口","slug":"sshtunnel","date":"2017-09-25T03:19:06.000Z","categories_index":"","tags_index":"ssh隧道","author_index":"ArcticTime"},{"id":"f0a9f68103bafda08057b264814a6ae9","title":"图片转字符","content":"usage: python pic2str.py xxx.jpg\nClick to see code\n# coding:utf-8  \n\n#  为一张图片生成对应的字符集图片  \n\nimport Image  \nimport argparse  \n\n# 命令行输入参数处理  \nparser = argparse.ArgumentParser()  \n\nparser.add_argument('file')     # 输入文件  \nparser.add_argument('-o', '--output')   # 输出文件  \nparser.add_argument('--width', type=int, default=140) # 输出字符画宽  \nparser.add_argument('--height', type=int, default=90) # 输出字符画高  \n\n# 获取参数  \nargs = parser.parse_args()  \n\nIMG = args.file  \nWIDTH = args.width  \nHEIGHT = args.height  \nOUTPUT = args.output  \n\nascii_char = list(\"$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1&#123;&#125;[]?-_+~&lt;>i!lI;:,\\\"^`'. \")  \n\n\n# 将256灰度映射到70个字符上  \ndef get_char(r, b, g, alpha=256):  \n    if alpha == 0:  \n        return ' '  \n    length = len(ascii_char)  \n    gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b)  \n\n    unit = (256.0 + 1)/length  \n    return ascii_char[int(gray/unit)]  \n\nif __name__ == '__main__':  \n\n    im = Image.open(IMG)  \n    im = im.resize((WIDTH, HEIGHT), Image.NEAREST)  \n\n    txt = \"\"  \n\n    for i in range(HEIGHT):  \n        for j in range(WIDTH):  \n            txt += get_char(*im.getpixel((j, i)))  \n        txt += '\\n'  \n\n    print txt  \n\n    # 字符画输出到文件  \n    if OUTPUT:  \n        with open(OUTPUT,'w') as f:  \n            f.write(txt)  \n    else:  \n        with open(\"output.txt\", 'w') as f:  \n            f.write(txt) \n\n\n\n","slug":"pic2str","date":"2017-08-15T10:49:36.000Z","categories_index":"python","tags_index":"tools","author_index":"ArcticTime"},{"id":"60ae5f459fdbd2a4d5acb3ac37fc6541","title":"快速找出故障机器","content":"关心数据挖掘和搜索引擎的朋友都知道，我们需要很多的计算机来存储和处理海量数据。然而，计算机难免出现硬件故障而导致网络联系失败或死机。为了保证搜索引擎的服务质量，我们需要保证每份数据都有多个备份。\n简单起见，我们假设一个机器仅储存一个标号为ID的记录（假设ID是小于10亿的整数），假设每份数据保存两个备份，这样就有两个机器储存了同样的数据。\n\n在某个时间，如果得到一个数据文件ID的列表，是否能够快速地找出这个表中仅出现一次的ID？\n如果已经知道只有一台机器死机（也就是说只有一个备份丢失）呢？如果有两台机器死机呢（假设同一个数据的两个备份不会同时丢失）？\n\n分析与解法\n\n\n\n\n\nTIP\n解法一这个问题可以转化成：有很多的ID，其中只有一个ID出现的次数小于2，其他正常ID出现的次数都等于2，问如何找到这个次数为1的ID。\n为了达到这个目的，最简单的办法就是直接遍历列表，利用一个数组记下每个ID出现的次数，遍历完毕之后，出现次数小于2的ID就是我们想要的结果。假设有N个ID，且ID的取值在0～（N-1）之间，这个解法占用的时间复杂度为O(N)，空间复杂度为O(N)。\n时间复杂度已经相当理想，但是空间复杂度仍觉不够理想。如果ID的数量多达几GB甚至几十GB，这样的空间复杂度在实际的运算中就会带来效率问题。那么，是否有办法进一步地减少空间复杂度呢？\n解法二仔细思考一下，哪些数据是不必存储的呢？大部分的机器ID出现次数都等于2，这些ID的信息有必要吗？我们可以利用这样一个特性：ID出现次数等于2的机器肯定不是故障的机器，可以不予考虑。因此，可以把解法1数组中等于2的元素清空，然后用来存储下一个机器ID的出现次数，这样就可以减少需要的空间。\n具体方法如下：遍历列表，利用哈希表记下每个ID出现的次数，每次遇见一个ID，就向哈希表中增加一个元素；如果这个ID出现的次数为2，那么就从哈希表中删除这个ID，最后剩下的ID就是我们想要的结果。这个算法空间复杂度在最好情况下可以达到O(1)，在最坏情况下仍然是O(N)。\n解法三前面的两个算法的时间复杂度已经达到了O(N)，并且空间复杂度也已经有了一定的突破，那么是否有可能进一步提高算法的性能呢？\n分别从时间复杂度，空间复杂度方面考虑，时间复杂度上面很难有太大的突破。因为，已经降到了O(N)这个规模了。那么，空间复杂度呢？\n如果想继续降低空间复杂度，就要摒弃遍历列表计数这种方法了，考虑采用完全不同的模式来计算。\n如果空间复杂度仍然在N这个级别，其实也没有降多少。是否可以降到常数级别呢？更加极端一点，是否可能使得空间复杂度降为O(1)，也就是说只利用一个变量来记录遍历列表的结果。\n如果这样，我们可以把这个变量写成：x(i)=f(list[0],list[1], …,list[i])，也就是说这个变量是已经遍历过的列表元素的函数。这个函数需要满足的条件就是：x(N)=ID_Lost。也就说遍历完整个列表后，这个变量的值应该等于丢失备份的ID。\n我们需要做的就是寻找合适的f。\n显然，f的形式不只一种。那么，我们可以先考虑找出一种可行的函数。对于第一问，我们已经知道，列表中仅有一个ID出现了一次。那么，可以考虑使用异或关系来帮忙找到结果。\n因为X⊕X=0且X⊕0=X，因此，可以把这个关系应用到构造这个函数上面。因为，正确的机器都会有两个ID，不正确的机器只有一个ID。所以所有ID的异或值就等于这个仅出现一次的ID（因为异或运算满足交换律和结合律，其他出现两次的ID异或完都为0）。这样我们只使用一次遍历运算就得到了只有一台故障机器情况下故障机器的ID。因此，就可以使用x(i)=list[0]⊕list[1]⊕…⊕list[i]来作为结果值。\n在这样的情况下，时间复杂度为O(N)，由于只需要保存一个运算结果，因此空间复杂度为O(1)。\n对于第二问，由于有两个ID仅出现了一次，设它们为A和B，那么所有ID的异或值为A⊕B（道理同上面分析的一样）。但还是无法确定A和B的值。\n可以进行分类讨论：如果A=B，则A⊕B为0，也就是说丢失的是同一份数据的两个拷贝，我们可以通过求和的方法得到A和B（A=B=(所有ID之和-所有正常工作机器ID之和)/2）。如果A⊕B不等于0，那么这个异或值的二进制中某一位为1。显然，A和B中有且仅有一个数的相同位上也为1。\n我们就把所有ID分成两类，一类在这位上为1，另一类这位上为0。那么对于这两类ID，每一类分别含有A和B中的一个。那么我们使用两个变量，在遍历列表时，分别计算这两类ID的异或和，即可得到A和B的值。\n\n","slug":"findbadmachine","date":"2016-09-26T03:33:26.000Z","categories_index":"","tags_index":"趣题","author_index":"ArcticTime"},{"id":"a44366009025b68a7362d7c10070d68f","title":"中国象棋将帅问题","content":"下过中国象棋的朋友都知道，双方的“将”和“帅”相隔遥远，并且不能照面。在象棋残局中，许多高手能利用这一规则走出精妙的杀招。假设棋盘上只有“将”和“帅”二子（如图所示）（为了下面叙述方便，我们约定用A表示“将”, B表示“帅”）。A、B二子被限制在己方3×3的格子里运动。例如，在如上的表格里，A被正方形{d10,f10, d8, f8}包围，而B被正方形{d3, f3, d1, f1}包围。每一步，A、B分别可以横向或纵向移动一格，但不能沿对角线移动。另外，A不能面对B，也就是说，A和B不能处于同一纵向直线上（比如A在d10的位置，那么B就不能在d1、d2以及d3的位置上）。请写出一个程序，输出A、B所有合法位置。\n分析与解法\n\n\n\n\n\nTIP\n问题本身并不复杂，只要把所有A、B互相排斥的条件列举出来就可以完成本题的要求。稍微思考一下，可以知道这个程序的大体框架是：\n\n遍历A的位置\n遍历B的位置\n判断A,B位置组合是否符合要求\n如果满足则输出\n\n\n\n\n\n因此，需要存储的是A、B的位置信息，并且每次循环都要更新。首先创建一个逻辑坐标系统，一个可行的方法是用1~9的数字，按照行优先的顺序来表示每个格点的位置（如图所示）。这样，只需要用模余运算就可以得到当前的列号，从而判断A、B是否互斥。\n\n\nClick to see code\nfor a := 1; a &lt;= 9; a++ &#123;\n    for b := 1; b &lt;= 9; b++ &#123;\n        if a%3 != b%3 &#123;\n            fmt.Printf(\"A=%d, B=%d\\n\", a, b)\n        &#125;\n    &#125;\n&#125;\n\n\n","slug":"chinchess","date":"2015-09-21T09:11:25.000Z","categories_index":"","tags_index":"趣题","author_index":"ArcticTime"},{"id":"ea3ce43666217b114197b9d0d5d2f463","title":"三个灯泡--三个开关","content":"房间里有三盏灯，屋外有三个开关，分别控制这三盏灯，只有进入房间，才能看到哪一个电灯是亮的。请问如何只进入房间一次，就能指明哪一个开关控制哪一个灯?\n","slug":"switch","date":"2015-08-07T03:43:13.000Z","categories_index":"","tags_index":"趣题","author_index":"ArcticTime"},{"id":"07c55e31248d72bce21e385abd54c291","title":"无重复字符的最长子串","content":"给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n示例 1:输入: s &#x3D; &quot;abcabcbb&quot;\n输出: 3 \n解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。\n示例 2:输入: s &#x3D; &quot;bbbbb&quot;\n输出: 1\n解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。\n示例 3:输入: s &#x3D; &quot;pwwkew&quot;\n输出: 3\n解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。\n示例 4:输入: s &#x3D; &quot;&quot;\n输出: 0\n方法一：滑动窗口\n\n\n\n\n\nTIP\n思路和算法我们先用一个例子考虑如何在较优的时间复杂度内通过本题。\n我们不妨以示例一中的字符串 abcabcbb 为例，找出从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：\n\n以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb;\n以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb;\n以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb;\n以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb;\n以 abca(b)cbb 开始的最长字符串为 abca(bc)bb;\n以 abcab(c)bb 开始的最长字符串为 abcab(cb)b;\n以 abcabc(b)b 开始的最长字符串为 abcabc(b)b;\n以 abcabcb(b) 开始的最长字符串为 abcabcb(b)。\n\n发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 rk 的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 rk，直到右侧出现了重复字符为止。\n这样一来，我们就可以使用「滑动窗口」来解决这个问题了：\n我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 rk\n在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度;\n在枚举结束后，我们找到的最长的子串的长度即为答案。\n判断重复字符在上面的流程中，我们还需要使用一种数据结构来判断 是否有重复的字符，常用的数据结构为哈希集合（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set， JavaScript 中的 Set）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。\n至此，我们就完美解决了本题。\n\n\nClick to see code\nfunc lengthOfLongestSubstring(s string) int &#123;\n    // 哈希集合，记录每个字符是否出现过\n    m := map[byte]int&#123;&#125;\n    n := len(s)\n    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动\n    rk, ans := -1, 0\n    for i := 0; i &lt; n; i++ &#123;\n        if i != 0 &#123;\n            // 左指针向右移动一格，移除一个字符\n            delete(m, s[i-1])\n        &#125;\n        for rk + 1 &lt; n &amp;&amp; m[s[rk+1]] == 0 &#123;\n            // 不断地移动右指针\n            m[s[rk+1]]++\n            rk++\n        &#125;\n        // 第 i 到 rk 个字符是一个极长的无重复字符子串\n        ans = max(ans, rk - i + 1)\n    &#125;\n    return ans\n&#125;\n\nfunc max(x, y int) int &#123;\n    if x &lt; y &#123;\n        return y\n    &#125;\n    return x\n&#125;\n\n\n复杂度分析\n时间复杂度：O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。\n空间复杂度：O(∣Σ∣)，其中 Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0, 128) 内的字符，即∣Σ∣=128。我们需要用到哈希集合来存储出现过的字符，而字符最多有∣Σ∣ 个，因此空间复杂度为O(∣Σ∣)。\n\n","slug":"strwithoutrepeatchar","date":"2015-04-20T07:44:37.000Z","categories_index":"algorithm","tags_index":"哈希表,字符串,滑动窗口","author_index":"ArcticTime"},{"id":"b612343628098f07bb289a1a081127cf","title":"两数相加","content":"给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储一位数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例 1：\n输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 &#x3D; 807.\n示例 2：输入：l1 &#x3D; [0], l2 &#x3D; [0]\n输出：[0]\n示例 3：输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]\n输出：[8,9,9,9,0,0,0,1]\n\n方法一: 模拟\n\n\n\n\n\nTIP\n思路与算法由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。\n我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为 n1,n2，进位值为 carry，则它们的和为 n1+n2+carry; 其中，答案链表处相应位置的数字为 (n1+n2+carry) mod 10, 而新的进位值为 n1+n2+carry/10\n如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0 。\n此外，如果链表遍历结束后，有 carry &gt; 0，还需要在答案链表的后面附加一个节点，节点的值为 carry。\n\n\nClick to see code\ntype ListNode struct &#123;\n    Val int\n    Next *ListNode\n&#125;\nfunc addTwoNumbers(l1, l2 *ListNode) (head *ListNode) &#123;\n    var tail *ListNode\n    carry := 0\n    for l1 != nil || l2 != nil &#123;\n        n1, n2 := 0, 0\n        if l1 != nil &#123;\n            n1 = l1.Val\n            l1 = l1.Next\n        &#125;\n        if l2 != nil &#123;\n            n2 = l2.Val\n            l2 = l2.Next\n        &#125;\n        sum := n1 + n2 + carry\n        sum, carry = sum%10, sum/10\n        if head == nil &#123;\n            head = &amp;ListNode&#123;Val: sum&#125;\n            tail = head\n        &#125; else &#123;\n            tail.Next = &amp;ListNode&#123;Val: sum&#125;\n            tail = tail.Next\n        &#125;\n    &#125;\n    if carry > 0 &#123;\n        tail.Next = &amp;ListNode&#123;Val: carry&#125;\n    &#125;\n    return\n&#125;\n\n\n复杂度分析\n时间复杂度：O(max(m,n))，其中 m 和 n 分别为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间。\n空间复杂度：O(1)。注意返回值不计入空间复杂度。\n\n","slug":"addtwonum","date":"2015-02-11T06:27:27.000Z","categories_index":"algorithm","tags_index":"递归,链表","author_index":"ArcticTime"},{"id":"5d27f50fa4c0422c709b72db5e188a60","title":"两数之和","content":"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例 1：输入：nums &#x3D; [2,7,11,15], target &#x3D; 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。\n示例 2：输入：nums &#x3D; [3,2,4], target &#x3D; 6\n输出：[1,2]\n示例 3：输入：nums &#x3D; [3,3], target &#x3D; 6\n输出：[0,1]\n\n\n方法一: 暴力枚举\n\n\n\n\n\nTIP\n思路及算法最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。\n当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。\n\n\nClick to see code\nfunc twoSum(nums []int, target int) []int &#123;\n    for i, x := range nums &#123;\n        for j := i + 1; j &lt; len(nums); j++ &#123;\n            if x+nums[j] == target &#123;\n                return []int&#123;i, j&#125;\n            &#125;\n        &#125;\n    &#125;\n    return nil\n&#125;\n\n\n复杂度分析\n时间复杂度：O(N^2)，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。\n空间复杂度：O(1)。\n\n方法二：哈希表\n\n\n\n\n\nTIP\n思路及算法注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。\n使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N) 降低到 O(1)。\n这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。\n\n\nClick to see code\nfunc twoSum(nums []int, target int) []int &#123;\n    hashTable := map[int]int&#123;&#125;\n    for i, x := range nums &#123;\n        if p, ok := hashTable[target-x]; ok &#123;\n            return []int&#123;p, i&#125;\n        &#125;\n        hashTable[x] = i\n    &#125;\n    return nil\n&#125;\n\n\n复杂度分析\n时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。\n空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。\n\n","slug":"sumtwonum","date":"2015-01-21T05:34:57.000Z","categories_index":"algorithm","tags_index":"哈希表","author_index":"ArcticTime"}]