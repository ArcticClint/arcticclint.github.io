[{"id":"f0a9f68103bafda08057b264814a6ae9","title":"图片转字符","content":"usage: python pic2str.py xxx.jpg\nClick to see code\n# coding:utf-8  \n\n#  为一张图片生成对应的字符集图片  \n\nimport Image  \nimport argparse  \n\n# 命令行输入参数处理  \nparser = argparse.ArgumentParser()  \n\nparser.add_argument('file')     # 输入文件  \nparser.add_argument('-o', '--output')   # 输出文件  \nparser.add_argument('--width', type=int, default=140) # 输出字符画宽  \nparser.add_argument('--height', type=int, default=90) # 输出字符画高  \n\n# 获取参数  \nargs = parser.parse_args()  \n\nIMG = args.file  \nWIDTH = args.width  \nHEIGHT = args.height  \nOUTPUT = args.output  \n\nascii_char = list(\"$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1&#123;&#125;[]?-_+~&lt;>i!lI;:,\\\"^`'. \")  \n\n\n# 将256灰度映射到70个字符上  \ndef get_char(r, b, g, alpha=256):  \n    if alpha == 0:  \n        return ' '  \n    length = len(ascii_char)  \n    gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b)  \n\n    unit = (256.0 + 1)/length  \n    return ascii_char[int(gray/unit)]  \n\nif __name__ == '__main__':  \n\n    im = Image.open(IMG)  \n    im = im.resize((WIDTH, HEIGHT), Image.NEAREST)  \n\n    txt = \"\"  \n\n    for i in range(HEIGHT):  \n        for j in range(WIDTH):  \n            txt += get_char(*im.getpixel((j, i)))  \n        txt += '\\n'  \n\n    print txt  \n\n    # 字符画输出到文件  \n    if OUTPUT:  \n        with open(OUTPUT,'w') as f:  \n            f.write(txt)  \n    else:  \n        with open(\"output.txt\", 'w') as f:  \n            f.write(txt) \n\n\n\n","slug":"pic2str","date":"2020-08-15T10:49:36.000Z","categories_index":"python","tags_index":"tools","author_index":"ArcticTime"},{"id":"ea2df330bdc4d3b0275544f615da7198","title":"gomail基本用法","content":"GoMail基本用法\nClick to see code\n// Example\n\nm := gomail.NewMessage()\nm.SetHeader(\"From\", \"alex@example.com\")\nm.SetHeader(\"To\", \"bob@example.com\", \"cora@example.com\")\nm.SetAddressHeader(\"Cc\", \"dan@example.com\", \"Dan\")\nm.SetHeader(\"Subject\", \"Hello!\")\nm.SetBody(\"text/html\", \"Hello &lt;b>Bob&lt;/b> and &lt;i>Cora&lt;/i>!\")\nm.Attach(\"/home/Alex/lolcat.jpg\")\n\nd := gomail.NewDialer(\"smtp.example.com\", 587, \"user\", \"123456\")\n\n// Send the email to Bob, Cora and Dan.\nif err := d.DialAndSend(m); err != nil &#123;\n\tpanic(err)\n&#125;\n\n\n// NoAuth\n\nm := gomail.NewMessage()\nm.SetHeader(\"From\", \"from@example.com\")\nm.SetHeader(\"To\", \"to@example.com\")\nm.SetHeader(\"Subject\", \"Hello!\")\nm.SetBody(\"text/plain\", \"Hello!\")\n\nd := gomail.Dialer&#123;Host: \"localhost\", Port: 587&#125;\nif err := d.DialAndSend(m); err != nil &#123;\n\tpanic(err)\n&#125;\n\n\n","slug":"gomail","date":"2019-03-11T03:50:45.000Z","categories_index":"golang","tags_index":"email","author_index":"ArcticTime"},{"id":"07c55e31248d72bce21e385abd54c291","title":"无重复字符的最长子串","content":"给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n示例 1:输入: s &#x3D; &quot;abcabcbb&quot;\n输出: 3 \n解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。\n示例 2:输入: s &#x3D; &quot;bbbbb&quot;\n输出: 1\n解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。\n示例 3:输入: s &#x3D; &quot;pwwkew&quot;\n输出: 3\n解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。\n示例 4:输入: s &#x3D; &quot;&quot;\n输出: 0\n方法一：滑动窗口\n\n\n\n\n\nTIP\n思路和算法我们先用一个例子考虑如何在较优的时间复杂度内通过本题。\n我们不妨以示例一中的字符串 \\texttt{abcabcbb}abcabcbb 为例，找出从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：\n\n以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb;\n以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb;\n以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb;\n以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb;\n以 abca(b)cbb 开始的最长字符串为 abca(bc)bb;\n以 abcab(c)bb 开始的最长字符串为 abcab(cb)b;\n以 abcabc(b)b 开始的最长字符串为 abcabc(b)b;\n以 abcabcb(b) 开始的最长字符串为 abcabcb(b)。\n\n发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 rk 的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 rk，直到右侧出现了重复字符为止。\n这样一来，我们就可以使用「滑动窗口」来解决这个问题了：\n我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 rk\n在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度;\n在枚举结束后，我们找到的最长的子串的长度即为答案。\n判断重复字符在上面的流程中，我们还需要使用一种数据结构来判断 是否有重复的字符，常用的数据结构为哈希集合（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set， JavaScript 中的 Set）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。\n至此，我们就完美解决了本题。\n\n\nClick to see code\nfunc lengthOfLongestSubstring(s string) int &#123;\n    // 哈希集合，记录每个字符是否出现过\n    m := map[byte]int&#123;&#125;\n    n := len(s)\n    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动\n    rk, ans := -1, 0\n    for i := 0; i &lt; n; i++ &#123;\n        if i != 0 &#123;\n            // 左指针向右移动一格，移除一个字符\n            delete(m, s[i-1])\n        &#125;\n        for rk + 1 &lt; n &amp;&amp; m[s[rk+1]] == 0 &#123;\n            // 不断地移动右指针\n            m[s[rk+1]]++\n            rk++\n        &#125;\n        // 第 i 到 rk 个字符是一个极长的无重复字符子串\n        ans = max(ans, rk - i + 1)\n    &#125;\n    return ans\n&#125;\n\nfunc max(x, y int) int &#123;\n    if x &lt; y &#123;\n        return y\n    &#125;\n    return x\n&#125;\n\n\n复杂度分析\n时间复杂度：O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。\n空间复杂度：O(|\\Sigma|)O(∣Σ∣)，其中 \\SigmaΣ 表示字符集（即字符串中可以出现的字符），|\\Sigma|∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0, 128)[0,128) 内的字符，即 |\\Sigma| = 128∣Σ∣=128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 |\\Sigma|∣Σ∣ 个，因此空间复杂度为 O(|\\Sigma|)O(∣Σ∣)。\n\n","slug":"strwithoutrepeatchar","date":"2015-04-20T07:44:37.000Z","categories_index":"algorithm","tags_index":"哈希表,字符串","author_index":"ArcticTime"},{"id":"b612343628098f07bb289a1a081127cf","title":"两数相加","content":"给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储一位数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例 1：\n输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 &#x3D; 807.\n示例 2：输入：l1 &#x3D; [0], l2 &#x3D; [0]\n输出：[0]\n示例 3：输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]\n输出：[8,9,9,9,0,0,0,1]\n\n方法一: 模拟\n\n\n\n\n\nTIP\n思路与算法:由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。\n我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为 n1,n2，进位值为 carry，则它们的和为 n1+n2+carry; 其中，答案链表处相应位置的数字为 (n1+n2+carry) mod 10, 而新的进位值为 n1+n2+carry/10\n如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0 。\n此外，如果链表遍历结束后，有 carry &gt; 0，还需要在答案链表的后面附加一个节点，节点的值为 carry。\n\n\nClick to see code\ntype ListNode struct &#123;\n    Val int\n    Next *ListNode\n&#125;\nfunc addTwoNumbers(l1, l2 *ListNode) (head *ListNode) &#123;\n    var tail *ListNode\n    carry := 0\n    for l1 != nil || l2 != nil &#123;\n        n1, n2 := 0, 0\n        if l1 != nil &#123;\n            n1 = l1.Val\n            l1 = l1.Next\n        &#125;\n        if l2 != nil &#123;\n            n2 = l2.Val\n            l2 = l2.Next\n        &#125;\n        sum := n1 + n2 + carry\n        sum, carry = sum%10, sum/10\n        if head == nil &#123;\n            head = &amp;ListNode&#123;Val: sum&#125;\n            tail = head\n        &#125; else &#123;\n            tail.Next = &amp;ListNode&#123;Val: sum&#125;\n            tail = tail.Next\n        &#125;\n    &#125;\n    if carry > 0 &#123;\n        tail.Next = &amp;ListNode&#123;Val: carry&#125;\n    &#125;\n    return\n&#125;\n\n\n复杂度分析\n时间复杂度：O(max(m,n))，其中 m 和 n 分别为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间。\n空间复杂度：O(1)。注意返回值不计入空间复杂度。\n\n","slug":"addtwonum","date":"2015-02-11T06:27:27.000Z","categories_index":"algorithm","tags_index":"递归,链表","author_index":"ArcticTime"},{"id":"5d27f50fa4c0422c709b72db5e188a60","title":"两数之和","content":"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例 1：输入：nums &#x3D; [2,7,11,15], target &#x3D; 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。\n示例 2：输入：nums &#x3D; [3,2,4], target &#x3D; 6\n输出：[1,2]\n示例 3：输入：nums &#x3D; [3,3], target &#x3D; 6\n输出：[0,1]\n\n\n方法一: 暴力枚举\n\n\n\n\n\nTIP\n思路及算法:最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。\n当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。\n\n\nClick to see code\nfunc twoSum(nums []int, target int) []int &#123;\n    for i, x := range nums &#123;\n        for j := i + 1; j &lt; len(nums); j++ &#123;\n            if x+nums[j] == target &#123;\n                return []int&#123;i, j&#125;\n            &#125;\n        &#125;\n    &#125;\n    return nil\n&#125;\n\n\n复杂度分析\n时间复杂度：O(N^2)，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。\n空间复杂度：O(1)。\n\n方法二：哈希表\n\n\n\n\n\nTIP\n思路及算法注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。\n使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N) 降低到 O(1)。\n这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。\n\n\nClick to see code\nfunc twoSum(nums []int, target int) []int &#123;\n    hashTable := map[int]int&#123;&#125;\n    for i, x := range nums &#123;\n        if p, ok := hashTable[target-x]; ok &#123;\n            return []int&#123;p, i&#125;\n        &#125;\n        hashTable[x] = i\n    &#125;\n    return nil\n&#125;\n\n\n复杂度分析\n时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。\n空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。\n\n","slug":"sumtwonum","date":"2015-01-21T05:34:57.000Z","categories_index":"algorithm","tags_index":"哈希表","author_index":"ArcticTime"}]